(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{144:function(e,t,r){"use strict";r.r(t),r.d(t,"frontMatter",(function(){return i})),r.d(t,"metadata",(function(){return c})),r.d(t,"rightToc",(function(){return p})),r.d(t,"default",(function(){return b}));var n=r(2),a=r(9),o=(r(0),r(158)),i={id:"either",title:"Either"},c={id:"syntax/either",isDocsHomePage:!1,title:"Either",description:"Either",source:"@site/../generated-docs/target/mdoc/syntax/either.md",permalink:"/docs/syntax/either",sidebar:"someSidebar",previous:{title:"Syntax",permalink:"/docs/syntax/syntax"},next:{title:"Option",permalink:"/docs/syntax/option"}},p=[{value:"Either",id:"either",children:[]},{value:"Right-Biased <code>Either</code>",id:"right-biased-either",children:[]},{value:"Either Constructors",id:"either-constructors",children:[]},{value:"<code>leftMap</code> and <code>leftFlatMap</code>",id:"leftmap-and-leftflatmap",children:[]}],l={rightToc:p};function b(e){var t=e.components,r=Object(a.a)(e,["components"]);return Object(o.b)("wrapper",Object(n.a)({},l,r,{components:t,mdxType:"MDXLayout"}),Object(o.b)("h2",{id:"either"},"Either"),Object(o.b)("h2",{id:"right-biased-either"},"Right-Biased ",Object(o.b)("inlineCode",{parentName:"h2"},"Either")),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"Either")," in Scala prior to 2.12 is not right-biased meaning that you have to call ",Object(o.b)("inlineCode",{parentName:"p"},"Either.right")," all the time if you want to use it with ",Object(o.b)("inlineCode",{parentName:"p"},"for-comprehension"),"."),Object(o.b)("p",null,"e.g.) Before 2.12"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-scala"}),"for {\n  b <- methodReturningEither(a).right\n  c <- anotherReturningEither(b).right\n} yield c\n")),Object(o.b)("p",null,"If you use ",Object(o.b)("inlineCode",{parentName:"p"},"just-fp"),", it becomes"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-scala"}),"import just.fp.syntax._\n")),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-scala"}),"for {\n  b <- methodReturningEither(a)\n  c <- anotherReturningEither(b)\n} yield c\n")),Object(o.b)("p",null,"Of course, you don't need to do it if you use Scala 2.12 or higher."),Object(o.b)("h2",{id:"either-constructors"},"Either Constructors"),Object(o.b)("p",null,"In normal ways, if you want to create ",Object(o.b)("inlineCode",{parentName:"p"},"Left")," or ",Object(o.b)("inlineCode",{parentName:"p"},"Right"),", you just use the ",Object(o.b)("inlineCode",{parentName:"p"},"apply")," methods of their companion objects (i.e. ",Object(o.b)("inlineCode",{parentName:"p"},"Left()")," ",Object(o.b)("inlineCode",{parentName:"p"},"Right()"),") A problem with this is that what these return is not ",Object(o.b)("inlineCode",{parentName:"p"},"Either")," but its data, ",Object(o.b)("inlineCode",{parentName:"p"},"Left")," or ",Object(o.b)("inlineCode",{parentName:"p"},"Right"),"."),Object(o.b)("p",null,"You also need to specify not only type parameter for ",Object(o.b)("inlineCode",{parentName:"p"},"Left")," but also the one for ",Object(o.b)("inlineCode",{parentName:"p"},"Right")," when creating ",Object(o.b)("inlineCode",{parentName:"p"},"Right"),"."),Object(o.b)("p",null,"e.g.) Without type parameters,"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-scala"}),"Right(1)\n// res0: Right[Nothing, Int] = Right(1)\n")),Object(o.b)("p",null,"You don't want to have ",Object(o.b)("inlineCode",{parentName:"p"},"Nothing")," there. So do it with type parameters,"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-scala"}),"Right[String, Int](1)\n// res1: Right[String, Int] = Right(1)\n")),Object(o.b)("p",null,"So it becomes unnecessarily verbose. Right should be inferred as the compiler knows it already yet to specify the left one, you have to put both left and right parameters."),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"Left"),", of course, has the same problem."),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-scala"}),'Left("error")\n// res2: Left[String, Nothing] = Left("error")\n')),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-scala"}),'Left[String, Int]("error")\n// res3: Left[String, Int] = Left("error")\n')),Object(o.b)("p",null,"Now with ",Object(o.b)("inlineCode",{parentName:"p"},"just-fp"),", it's simpler. You can use use ",Object(o.b)("inlineCode",{parentName:"p"},"left")," and ",Object(o.b)("inlineCode",{parentName:"p"},"right")," constructors as extension methods to the actual data values with only missing type info specified."),Object(o.b)("p",null,"e.g.)"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-scala"}),"1.right[String] // Now you only need to specify\n// res4: Either[String, Int] = Right(1)\n")),Object(o.b)("p",null,"For ",Object(o.b)("inlineCode",{parentName:"p"},"Left"),","),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-scala"}),'"error".left[Int]\n// res5: Either[String, Int] = Left("error")\n')),Object(o.b)("h2",{id:"leftmap-and-leftflatmap"},Object(o.b)("inlineCode",{parentName:"h2"},"leftMap")," and ",Object(o.b)("inlineCode",{parentName:"h2"},"leftFlatMap")),Object(o.b)("p",null,"So if you Scala 2.12 or higher or ",Object(o.b)("inlineCode",{parentName:"p"},"just-fp")," with the older Scala, ",Object(o.b)("inlineCode",{parentName:"p"},"Either")," is right-biassed. Then what about the ",Object(o.b)("inlineCode",{parentName:"p"},"Left")," case? Can I ever use ",Object(o.b)("inlineCode",{parentName:"p"},"Left")," for something useful like transforming the ",Object(o.b)("inlineCode",{parentName:"p"},"Left")," value to something else?"),Object(o.b)("p",null,"For that, ",Object(o.b)("inlineCode",{parentName:"p"},"just-fp")," has added ",Object(o.b)("inlineCode",{parentName:"p"},"leftMap")," and ",Object(o.b)("inlineCode",{parentName:"p"},"leftFlatMap")," to ",Object(o.b)("inlineCode",{parentName:"p"},"Either"),".\ne.g.)"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-scala"}),'import just.fp.syntax._\n\nfinal case class ComputeError(error: String)\n\nsealed trait AppError\nobject AppError {\n  final case class InvalidNumberError(error: String) extends AppError\n  final case class ComputationError(computeError: ComputeError) extends AppError\n\n  def invalidNumberError(error: String): AppError =\n    InvalidNumberError(error)\n  def fromComputeError(computeError: ComputeError): AppError =\n    ComputationError(computeError)\n}\n\ndef f1(n: Int): Either[String, Int] =\n  if (n < 0)\n    Left(s"The number must be non-negative integer - n: $n")\n  else\n    Right(n)\n\ndef f2(x: Int, y: Int): Either[ComputeError, Int] = {\n  val z = x + y\n  if (x >= 0 && y >= 0 && z < 0)\n    Left(ComputeError(s"Numbers are too big - x: $x, y: $y"))\n  else\n    Right(x + y)\n}\n')),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-scala"}),"for {\n  b <- f1(10).leftMap(AppError.invalidNumberError)\n  c <- f2(123, b).leftMap(AppError.fromComputeError)\n} yield c\n// res7: Either[AppError, Int] = Right(133)\n")),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-scala"}),'for {\n  b <- f1(-1).leftMap(AppError.invalidNumberError)\n  c <- f2(123, b).leftMap(AppError.fromComputeError)\n} yield c\n// res8: Either[AppError, Int] = Left(\n//   InvalidNumberError("The number must be non-negative integer - n: -1")\n// )\n')),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-scala"}),'for {\n  b <- f1(Int.MaxValue).leftMap(AppError.invalidNumberError)\n  c <- f2(1, b).leftMap(AppError.fromComputeError)\n} yield c\n// res9: Either[AppError, Int] = Left(\n//   ComputationError(ComputeError("Numbers are too big - x: 1, y: 2147483647"))\n// )\n')))}b.isMDXComponent=!0},158:function(e,t,r){"use strict";r.d(t,"a",(function(){return s})),r.d(t,"b",(function(){return d}));var n=r(0),a=r.n(n);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function i(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function c(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?i(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function p(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var l=a.a.createContext({}),b=function(e){var t=a.a.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):c(c({},t),e)),r},s=function(e){var t=b(e.components);return a.a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},m=a.a.forwardRef((function(e,t){var r=e.components,n=e.mdxType,o=e.originalType,i=e.parentName,l=p(e,["components","mdxType","originalType","parentName"]),s=b(r),m=n,d=s["".concat(i,".").concat(m)]||s[m]||u[m]||o;return r?a.a.createElement(d,c(c({ref:t},l),{},{components:r})):a.a.createElement(d,c({ref:t},l))}));function d(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=r.length,i=new Array(o);i[0]=m;var c={};for(var p in t)hasOwnProperty.call(t,p)&&(c[p]=t[p]);c.originalType=e,c.mdxType="string"==typeof e?e:n,i[1]=c;for(var l=2;l<o;l++)i[l]=r[l];return a.a.createElement.apply(null,i)}return a.a.createElement.apply(null,r)}m.displayName="MDXCreateElement"}}]);